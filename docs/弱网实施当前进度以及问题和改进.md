# 弱网实施当前进度以及问题和改进

Author: qians

Date: 2023/5/23

Version: 0.0.1

## 进度

目前实现了服务端发送消息的等待ACK和重发机制, 实现了批量ACK滑动窗口机制. 对于客户端消息的返回ACK, 实现了, 但暂时屏蔽了(需要等待客户端实现ACK协议和重发). 重发机制中的间隔时间, 最大重试次数, ACK滑动窗口尺寸都实现了动态配置.

## 问题和可能的解决

### 和当前压缩实现冲突

出于性能考虑, 目前的架构中压缩是在代理(Proxy)层中完成(发送时再压缩的话, 一条消息要重复压缩N次). 这就导致了到达具体发送时, 待发送消息是无意义的, 我无法从中获取我需要的msg_id来作为Ack的trace_id.

最简单的解决方法就是只压缩Content部分, 再将消息协议的头(length, msg_id, timestamp)追加上. 但是这里存在一个问题, 压缩后实际length长度发生了改变, 需要重新生成. 若是重新生成的话, 那是否可以协议头不由Java业务端生成. 或者能否更近一步, 消息协议能否直接去除协议头, 统一使用控制协议头, 传递给业务端时, 只包含具体消息体(Content). 协议头只在前端和连接层中处理.

### Websocket的消息协议不一致

当前实现中, websocket的消息协议是不完整的, 只包含了完整协议的消息体(Content)部分. 这就导致了我没法像TCP那样从消息头中获取msg_id作为trace_id(ACK的唯一标识).

最简单的解决方法即Websocket也按照消息协议发送, 但我更倾向于协议头全部替换为控制协议的协议头, 将消息协议的消息体并入控制协议中(在下文详细描述可行性).

### 当前msg_id太长了

当前实现中, msg_id长度为32字节. 协议头仅1字节, 若批量ACK3个msg, 那消息长度就达到97字节了.
作为实际是为弱网准备的协议, 这可能有些过长了.
其次, 由于每条消息都需要ACK, 所以ACK消息的量在整个系统中也是非常巨大的, 处于流量的考虑, 我们也应该让ACK消息尽可能的小.

我的建议是可以使用仅8字节(64位)雪花ID作为协议头中的trace_id. 另一个好处是, 使用雪花id的话, 我可以从中取出41位的毫秒级时间戳, 这样协议中的时间戳也可以省略. 这样的话同样批量ACK3个msg, 消息长度就从97降低到25个字节了.

### 总结

总的来说, 都是之前的消息协议设计和使用时没有考虑弱网情况, 导致了目前实施弱网方案时的不适配. 所以我的建议是协议头统一使用连接层控制协议协议头, 将消息协议兼容进控制协议中. 且协议头仅在客户端和连接层之间使用, 向业务端传递时, 只传递消息体. 这样也更加符合模块化的原则: 业务端实际上并不需要处理粘包拆包, ACK, 弱网, 心跳等情况.

### 控制协议头兼容消息协议的可行性

- 控制协议头: 8位(1字节)

| 1位网络质量标识位 | 1位心跳标识位 | 1位ACK标识位 | 1位弱网包标识位                       | 4位数量标识位 |
| ----------------- | ------------- | ------------ | ------------------------------------- | ------------- |
| 0:正常, 1:质量差  | 1:心跳包      | 0:关闭       | 0:关闭, 和ACK同时关闭时表示为普通消息 | 0-15, 数量    |

- Content追加消息头

| 16位(两字节)消息体长度 | 64位(8字节)trace_id                |
| ---------------------- | ---------------------------------- |
| 0-65535                | 雪花id, 可以从中逆向取出41位时间戳 |

- Content消息体

不变, 和消息协议中的相同.

当头中的ACK标识位和弱网标识位同时关闭时, 即本消息既不是ACK, 也不是弱网包, 也不是弱网ACK. 此中情况我们就可以用来表示普通消息, 这样就将普通消息协议.
