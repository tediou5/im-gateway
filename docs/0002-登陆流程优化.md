- Feature: 登陆流程优化
- Start Date: 2023/6/5
- Version: 0.0.1
# Summary

用户登陆时, 连接层直接根据Token解析出Appid和Pin. 并通过kafka通知业务端. 业务端完成登陆后用户元数据(chats)也通过kafka传递给连接层.

# Motivation

目前当用户登陆时, 实际分为两部分.

1. 连接层接受登陆报文, 通过HTTP请求业务层, 业务层通过HTTP返回登陆结果和数据.
2. 连接层根据返回的pin和chats数据将该连接分配至莫线程上, 并更新users和chats. 完成登陆.

这里主要问题是HTTP请求会导致性能受影响且和业务端的绑定比较死. 不利于业务端进行分布式部署.

# Guide-level explanation

之所以之前如此设计. 实际上是由于当时认为在登陆时我无法获知用户的Pin(我只能获取到他的Token), 所以无法将该连接存放到users中. 也就没法处理接下来kafka传来的后续的数据.

但实际上我只需要和业务层协商好`secret key`就可以按照JWTs协议解析出Token中的Appid和Pin, 就可以更新Users并通过kafka正确的处理该连接后续的任务了.

## 优化后的登陆流程

优化后的登陆流程需要在推送协议中添加登陆(login)和断开(disconnect)事件, 并分3步完成登陆:

1. 连接层接受登陆报文, 从Token中解析出Appid和Pin. 将该连接更新至users中. 此时实际上用户已经完成登陆了, 只是尚未更新该用户的chats数据, 还无法推送chat相关消息.
2. 通过kafka将用户登陆请求传递至业务层.
3. 业务端处理好用户登陆的请求后, 将chats通过login事件传递进连接层. 若失败则调用disconnect事件断开用户连接.

## 推送协议更新

### login

### disconnect

# Prior art

此方案属于后端逻辑的优化, 对前端是无影响的, 能够保证向前兼容性. 对业务层也反而是更加的友好了: 不需要单独使用HTTP来处理登陆, 与别的请求一同使用kafka进行交互.
但对于连接层, 切换至此方案需要做不小的改动, 但我认为这还是值得的.

