# 连接层弱网实施方案

Author: qians

Date: 2023/5/19

Version: 0.0.1

## 简述

弱网问题普遍存在且原因多种多样, 我主要做两方面的努力:

1. 对于整个系统的网络质量和传输进行通用的优化和改进(基础不好, 弱网情况下肯定更差).
2. 针对每个特定场景做针对性优化, 力求做到覆盖和最大程度努力.

另外弱网处理作为连接层事件, 我认为最好使用一套独立的连接控制协议, 以减少ACK长度提高性能并最大化和业务解耦.

## 场景与解决方法

这里都以服务器向客户端推送时出现弱网为例.

### 突发性网络波动(核心, 高优先级)

用户短时间内进入弱网环境, 例如网络突然出现波动, 进入电梯或者隧道中等. 在一段时间后会恢复正常传输.
针对这种情况下, 我们只需要进行反复重试, 并在网络恢复正常后恢复推送即可.
具体场景如下:

1. 服务器收到一条推送请求, 尝试将消息推出.
2. 服务器等待接收客户端对此消息的ACK(确认送达消息)

   - 如果服务器接收到ACK, 则回到步骤一继续尝试推送下一跳消息.
   - 如果服务器在等待一段时间后没有收到ACK消息, 则会认为消息丢失. 服务器会重复尝试推送本条消息, 直至收到ACK或者超过设定的重试条件断开连接(具体重试条件在之后专门讨论).

### 长期处于弱网环境(核心, 高优先级)

用户本身处于并长期处于弱网环境中, 例如在信号覆盖边缘的工作人员, 网络拥堵的会场中等. 可预期的很长时间内用户的网络环境都不会改观.
针对这种情况下, 我们如果只是简单的反复重发可能就达不到效果了, 因为用户的网络质量很可能就是无法接收消息.
这时服务器就会将单个消息包(最大1800B), 拆分成多个小包(例如每个50B), 并进行发送.
具体场景如下:

1. 服务器收到一条推送请求, 尝试将消息推出.
2. 服务器在重试多次依然没有收到ACK后, 则认为用户长期处于弱网环境中, 切换发送模式至弱网模式.
3. 弱网模式下, 会将每次发生的包的大小缩小到「设定」大小, 分成N个包发送出去. 并重发直至收到ACK或超过设定的重试条件.
4. 若是客户端连服务器的弱网包都无法ACK的话, 则认为改连接处于不可用的状态, 因此放弃重试直接断开连接.

## 通用场景优化

### 用户连接时选择质量更高的服务器连接(可选优化, 低优先级)

用户在建立连接时, 不是随机连接至某台服务器. 而且向HTTPDNS服务器请求一台(或多台)更适合(地理位置更近, 负载更低)的服务器发起连接. 以达到降低网络延迟的目的.

### 用户由于地域切换导致的网络质量变差(可选优化, 低优先级)

用户的网络是正常的, 畅通的. 只是由A地到达B地, 但连接的依然是A地的路由/服务器. 导致用户虽然能收到消息但消息的延迟增高了, 影响了正常使用.
这种情况下, 只需要让用户重新选择连接的服务器即可, 具体场景如下:

1. 客户端正常收发消息, 但是用户的ACK延迟都比较高.
2. 服务器下发控制协议通知客户端网络质量差.
3. 客户端收到后, 重新进行服务器选择. 若存在更高质量的服务器, 则断开当前连接, 切换至新服务器.

## 连接控制报文设计

作为一个连接层的控制报文协议, 我设计的目标是:

1. 在不改变消息协议的前提下, 能将两种协议区分开来.
2. 两种协议互相0依赖, 做到完全独立.
3. 协议设计尽可能精简.

### 可行性说明

在当前的消息协议的报文中, 前4个字节是32位的int类型, 用来表示content的长度. 但由于content的长度永远大于等于0, 且永远不可能大于65535位.
所以实际上这4个字节只用到了后两个字节, 前两个字节(16个bit)永远都为0.
那么我只需要判断第一个字节是否为0即可区分开是消息协议还是控制协议.

### 详细设计

- 控制协议头: 8位(1字节)

| 1位网络质量标识位 | 1位心跳标识位 | 1位ACK标识位 | 1位弱网包标识位                        | 4位数量标识位                             |
| ----------------- | ------------- | ------------ | -------------------------------------- | ----------------------------------------- |
| 0:正常, 1:质量差  | 1:心跳包      | 1:开启       | 1:开启, 和ACK同时开启时表示为弱网包ACK | 0-15, 表示弱网包拆分数量或者批量ACK的数量 |

- 控制协议体
  - 弱网包

    | msgid          | 4位弱网包序号 | 4位当前重试次数 | 8位弱网包长度 | 弱网包内容 |
    | -------------- | ------------- | --------------- | ------------- | ---------- |
    | 被拆分的包的id | 0-15          | 0-15            | 0-255         | content    |

  - ACK

    | ACK包内容              |
    | ---------------------- |
    | 长度为ACK数量 * id长度 |

  - 弱网包ACK

    | msgid          | ACK包内容                                          |
    | -------------- | -------------------------------------------------- |
    | 被拆分的包的id | 长度为ACK数量 * 弱网包序号(每个序号占8位, 即1字节) |

### 重试条件

1. 第一次尝试推送后, 等待3(可配置)秒未收到ACK则进行第二次尝试.
2. 第二次尝试推送后, 等待(2 * 3)秒未收到ACK则进行第三次尝试.
3. 第三次尝试推送后, 等待(4 * 3)秒未收到消息则进行第四次尝试.
4. 第四次尝试推送后, 等待(4 * 3)秒未收到消息则进行第五次尝试.

第五次尝试后(可配置), 若等待(4 * 3)秒仍然未收到消息, 则进入弱网推送模式.

1. 将单个大包, 按照设定(拆分数量或者单个包最大大小)拆分为N个弱网包, 并装入控制协议的弱网包协议中.
2. 依次将这N个包全部推出. 重试逻辑如上, 只不过变更为没有全部ACK则继续重试剩下的, 直至五次尝试但是一个ACK都没收到情况下, 才断开连接. 只要还有一个小包ACK了, 都会继续尝试.

### 改进的点

#### msgid长度过长

目前消息协议头中的msgid为32字节, 对于控制协议来说, 太长了. 能否替换成别的更短的唯一id(雪花id仅8字节, 单机唯一), 业务端不使用协议头中的, 而使用协议体内部的msg_id.

#### 批量ACK的讨论

如果每次ACK一条才发一条, 整体的延迟会高很多. 但若是批量ACK的话有个问题是每个消息都是单独的定时器的话, 对整体性能影响太大了(定时器太多了).
因此我倾向于使用TCP协议中的滑动窗口机制, 每个连接都设计一个ACK窗口(大小0-15可配置):

1. 每次发送时先检查窗口是否已经占满.
   - 如果没有, 则推送该消息, 并将该消息加入窗口中.
   - 如果已满, 则停止推送, 等待窗口有空余出现.
2. 每当收到ACK时, 则将窗口中对应的的移除.
3. 如果加入弱网模式, 则只会取出第一个包拆分成弱网包进行弱网模式推送.
